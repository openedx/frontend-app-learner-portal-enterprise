# 0010. Adjust production Webpack configuration for regarding code splitting

## Status

Accepted (February 2024)

## Context

Currently, the default Webpack configuration provided by ``@openedx/frontend-build`` generally relies on default options for code splitting support with the ``SplitChunksPlugin``. That is, by default, ``optimization.splitChunks`` is only configured with the following:

```json
{
    "optimization": {
        "splitChunks": {
            "chunks": "all"
        }
    }
}
```

However, this existing configuration only provides support for dynamic imports within the micro-frontend code implementation; that is, it does not attempt to change the underlying behavior in terms of the generated files without modifications to implemented code in the ``src`` directory of this project.

Additionally, in the default configuration, Webpack generate chunks that exceed its recommended 244 KiB, which results in larger but fewer bundles. This approach plays into the long-term caching strategy in that files generated by Webpack have a unique hash included in the file (e.g., ``351.e63ea30c212ef5e46b4b.js``) such that browsers can cache the file asset, only having to re-download when the hash is changed due to changes in the underlying code or third-party dependencies (``node_modules``). For example, if all ``node_modules`` are bundled in a single chunk, as it the case today, if just one of those ``node_modules`` is upgraded or a new dependency is installed via ``package.json``, users are forced to re-download a new file with a newly generated hash.

Ideally, a change in code and/or an upgrade to an installed third-party dependency should have minimal impact on forcing users to re-download already cached file assets. That is, if vendor packages can be split into smaller, more granular chunks, they can be requested in parallel (which is adequetely supported in HTTP/2) and kept as a longer-term cached file due to the smaller chunk changing less frequently.

This ADR proposes modifying the default production Webpack configuration provided by ``@openedx/frontend-build`` to improve frontend performance as explained below.

## Decision

We will extend the default production Webpack configuration from ``@openedx/frontend-build`` to change its ``optimization`` options:

1. We will explicitly set `moduleIds: 'deterministic'`. This ensures that Webpack generates module IDs based on the content of the module, meaning that if the content of a module remains the same, its module ID will also remain consistent across builds.
1. We will configure ``maxSize`` to be 244 KiB, per Webpack's recommendation. Note, this takes precedence over the Webpack options ``maxInitialRequest`` and ``maxAsyncRequests``. ``maxSize`` should only be used alongside HTTP/2 which has improved support for managing multiple small requests in parallel compared to HTTP/1.1.
1. We will introduce the following custom ``cacheGroups`` (all inherit the ``maxSize`` described above):
    * ``vendors``. Handles third-party dependencies (i.e., ``node_modules``), given them the lowest priority of the configured cache groups. This ``priority`` is slightly higher than the ``priority`` set in the ``defaultVendors`` option (disabled).
    * ``reactVendor``. Bundles React and its related libraries (ReactDOM, React Router) into a single chunk that has highest priority.
    * ``paragonVendor``. Co-locates Paragon related imports such that chunks specific to Paragon only get cache invalidated due to explicit Paragon upgrades.
    * ``edXVendor``. Combines ``@edx`` and ``@openedx`` shared NPM libraries (e.g., ``@openedx/frontend-platform``). Similar to ``paragonVendor``, this helps with long-term caching such that these chunks will only be invalidated and re-downloaded if the relevant packages are explicitly upgraded.


## Consequences

* A larger number of smaller files are generated when building the micro-frontend for production with ``npm run build`` through Webpack.
* Some of the generated files are the result of custom ``cacheGroups`` that attempt to bundle similar and/or related code together (e.g., co-locate React and its associated libraries in a single chunk).
* When serving the production build during local development for QA, the ``npm run serve`` command (exposed as a script via ``@openedx/frontend-build``) does not serve assets using the HTTP/2 protocal; rather, it relies on HTTP/1.1 instead, which does not handle making as many smaller, parallel requests as well as HTTP/2. We are accepting this as an acceptable tradeoff given the biggest concern with serving the production assets locally is to ensure nothing has functionally regressed with regard to code splitting, even if the performance isn't exactly matching what it'd be on stage/production.

## Alternatives Considered

* Only rely on more application/code implementation changes (e.g., with dynamic imports and `React.lazy` with `Suspense`) when working with code splitting. This was ruled out as there are opportunities for paralleling a larger number of small requests even if those chunks are not dynamically imported.
* Ensure the ``npm run serve`` command can utilize the HTTP/2 protocol. This was ruled out as it would require engineers to run the application under SSL and may need additional changes to get around issues regarding configuration and CORS.
