# 0010. Adjust production Webpack configuration for regarding code splitting

## Status

Accepted (February 2024)

## Context

Currently, the default Webpack configuration provided by ``@openedx/frontend-build`` generally relies on default options for code splitting support with the ``SplitChunksPlugin``. That is, by default, ``optimization.splitChunks`` is only configured with the following:

```json
{
    "optimization": {
        "splitChunks": {
            "chunks": "all"
        }
    }
}
```

However, this existing configuration only provides support for dynamic imports within the micro-frontend code implementation; that is, it does not attempt to change the underlying behavior in terms of the generated files without modifications to implemented code in the ``src`` directory of this project.

Additionally, in the default configuration, Webpack generate chunks that exceed its recommended 244 KiB, which results in larger but fewer bundles. This approach plays into the long-term caching strategy in that files generated by Webpack have a unique hash included in the file (e.g., ``351.e63ea30c212ef5e46b4b.js``) such that browsers can cache the file asset, only having to re-download when the hash is changed due to changes in the underlying code or third-party dependencies (``node_modules``). For example, if all ``node_modules`` are bundled in a single chunk, as it the case today, if just one of those ``node_modules`` is upgraded or a new dependency is installed via ``package.json``, users are forced to re-download a new file with a newly generated hash.

Ideally, a change in code and/or an upgrade to an installed third-party dependency should have minimal impact on forcing users to re-download already cached file assets. That is, if vendor packages can be split into smaller, more granular chunks, they can be requested in parallel (which is adequetely supported in HTTP/2) and kept as a longer-term cached file due to the smaller chunk changing less frequently.

This ADR proposes modifying the default production Webpack configuration provided by ``@openedx/frontend-build`` to improve frontend performance as explained below.

## Decision

We will extend the default production Webpack configuration from ``@openedx/frontend-build`` to change its ``optimization`` options:

1. We will explicitly set `moduleIds: 'deterministic'`. This ensures that Webpack generates module IDs based on the content of the module, meaning that if the content of a module remains the same, its module ID will also remain consistent across builds.
1. We will configure ``maxSize`` to be 244 KiB, per Webpack's recommendation. Note, this takes precedence over the Webpack options ``maxInitialRequest`` and ``maxAsyncRequests``. ``maxSize`` should only be used alongside HTTP/2 which has improved support for managing multiple small requests in parallel compared to HTTP/1.1.
1. We will continue to rely on the default ``cacheGroups`` provided by Webpack, though all will inherit the ``maxSize`` described above.

By setting ``maxSize``, Webpack will make its best effort to keep chunk sizes below 244 KiB (parsed size). We will not modify default ``cacheGroups`` such that default chunk naming conventions and behavior continues to work.

These changed are intended to be used alongside dynamic imports (e.g., with ``lazy`` and ``Suspense``) within the application to lazy load or defer chunks until relevant in the users' interaction (e.g., Plotly.js should only be loaded if rendering the associated spider chart). We will adopt route splitting such that Webpack generates chunks specific to individual page routes, whereby only the application code and/or third-party dependencies relevant to the individual, rendered page are included. 

For example, the course page route depends on a relatively large library, ``video.js``; only the course page relies on ``video.js``. Before this ADR, when a page route other than the course page is viewed, all the course page related code still needs to load. Through this ADR and route splitting, the course page has its own chunks specific to the individual route, including a ``vendors-course-<hash>.<hash>.js`` file containing ``video.js``. Note, this generated chunk for ``video.js`` is still only loaded when viewing the course page route.


## Consequences

* A larger number of smaller files are generated when building the micro-frontend for production with ``npm run build`` through Webpack.
* Some of the generated files are the result of custom ``cacheGroups`` that attempt to bundle similar and/or related code together (e.g., co-locate React and its associated libraries in a single chunk).
* When serving the production build during local development for QA, the ``npm run serve`` command (exposed as a script via ``@openedx/frontend-build``) does not serve assets using the HTTP/2 protocal; rather, it relies on HTTP/1.1 instead, which does not handle making as many smaller, parallel requests as well as HTTP/2. We are accepting this as an acceptable tradeoff given the biggest concern with serving the production assets locally is to ensure nothing has functionally regressed with regard to code splitting, even if the performance isn't exactly matching what it'd be on stage/production.

## Alternatives Considered

* Only rely on more application/code implementation changes (e.g., with dynamic imports and `lazy` with `Suspense`) when working with code splitting. This was ruled out as there are opportunities for parallelizing a larger number of small requests even if those chunks are not dynamically imported.
* Define custom Webpack ``cacheGroups`` through ``SplitChunksPlugin``. This was decided against as it creates chunks containing components not relevant to all page routes and/or user interactions. For instance, if we defined a ``paragonVendor`` cache group with the intent to co-locate all Paragon components together, this would mean users need to essentially download code for all Paragon components, even ones unused for the given page route. Instead, we rather rely on default Webpack behavior whereby only the actual components necessary for the active page route and/or user interaction are included in the dynamic, lazily loaded chunk instead. More concretely, we would like to defer the loading of any Paragon components not currently used to reduce blocking network requests on initial page load.
* Ensure the ``npm run serve`` command can utilize the HTTP/2 protocol. This was ruled out as it would require engineers to run the application under SSL and may need additional changes to get around issues regarding configuration and CORS.
